#ifndef Provision_h
#define Provision_h

// Local includes.
#include "Provision_Callback.h"
#include "IAPI_Implementation.h"




/// @brief Handles the internal implementation of the ThingsBoard provision API.
/// See https://thingsboard.io/docs/user-guide/device-provisioning/ for more information
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = UdawaThingsboardLogger
template <typename Logger = UdawaThingsboardLogger>
class Provision : public IAPI_Implementation {
    public:
        /// @brief Constructor
        Provision() = default;

        ~Provision() override = default;

        /// @brief Requests othe provisioning of a new device, which will call the passed callback.
        /// If the credentials from the server for the requested provisioned device have been received
        /// @note The configured provision device key / secret decide which device profile is used to create the device from.
        /// Optionally a device name can be passed or be left empty (cloud will use a random string as the name instead).
        /// The data contained in that callback, being the device credentials, can then be used to disconnect and reconnect to the ThingsBoard server as our newly created device.
        /// Because the provisiong request is a single event subscription, meaning we only ever receive one response for one request,
        /// the request is automatically unsubscribde and the internally allocated data for the request deleted as soon as the response has been received and handled by the subscribed callback.
        /// See https://thingsboard.io/docs/user-guide/device-provisioning/ for more information
        /// @param callback Callback method that will be called when the requested provision response has been received
        /// @return Whether sending the request to the cloud was successfull. Is non-blocking and therefore a true value returned by this method does not guarantee a response will ever be received.
        /// If wanted by the user the optional timeout callback and timeout time in the callback instance can be configured,
        /// which will inform the user by calling the timeout callback, if no response has been received by the server in the expected time
        bool Provision_Request(Provision_Callback const & callback) {
                char const * provision_device_key = callback.Get_Device_Key();
                char const * provision_device_secret = callback.Get_Device_Secret();

                if (Helper::String_IsNull_Or_Empty(provision_device_key) || Helper::String_IsNull_Or_Empty(provision_device_secret)) {
                        return false;
                }
                else if (!Provision_Subscribe(callback)) {
                        return false;
                }

                JsonDocument request_buffer;
                char const * device_name = callback.Get_Device_Name();
                char const * access_token = callback.Get_Device_Access_Token();
                char const * cred_username = callback.Get_Credentials_Username();
                char const * cred_password = callback.Get_Credentials_Password();
                char const * cred_client_id = callback.Get_Credentials_Client_ID();
                char const * hash = callback.Get_Certificate_Hash();
                char const * credentials_type = callback.Get_Credentials_Type();

                // Deciding which underlying provisioning method is restricted, by the Provision_Callback class.
                // Meaning only the key-value pairs that are needed for the given provisioning method are set,
                // resulting in the rest not being sent and therefore the provisioning request having the correct formatting
                if (!Helper::String_IsNull_Or_Empty(device_name)) {
                        request_buffer[PROV_DEVICE_NAME] = device_name;
                }
                if (!Helper::String_IsNull_Or_Empty(access_token)) {
                        request_buffer[PROV_ACCESS_TOKEN_KEY] = access_token;
                }
                if (!Helper::String_IsNull_Or_Empty(cred_username)) {
                        request_buffer[PROV_CRED_USERNAME] = cred_username;
                }
                if (!Helper::String_IsNull_Or_Empty(cred_password)) {
                        request_buffer[PROV_CRED_PASSWORD] = cred_password;
                }
                if (!Helper::String_IsNull_Or_Empty(cred_client_id)) {
                        request_buffer[PROV_CRED_CLIENT_ID] = cred_client_id;
                }
                if (!Helper::String_IsNull_Or_Empty(hash)) {
                        request_buffer[PROV_CRED_HASH] = hash;
                }
                if (!Helper::String_IsNull_Or_Empty(credentials_type)) {
                        request_buffer[PROV_CRED_TYPE] = credentials_type;
                }
                request_buffer[PROV_PROV_DEVICE_KEY] = provision_device_key;
                request_buffer[PROV_PROV_DEVICE_SECRET] = provision_device_secret;
                auto & request_callback = m_provision_callback.Get_Request_Timeout();
                request_callback.Start_Timeout_Timer();
                return m_send_json_callback.Call_Callback(PROV_REQUEST_TOPIC, request_buffer, Deserialization_Options::NONE);
        }

        API_Process_Type Get_Process_Type() const override {
                return API_Process_Type::JSON;
        }

        void Process_Response(char const * topic, uint8_t * payload, uint32_t length) override {
                // Nothing to do
        }

        void Process_Json_Response(char const * topic, const JsonDocument& data) override {
                auto & request_callback = m_provision_callback.Get_Request_Timeout();
                request_callback.Stop_Timeout_Timer();
                m_provision_callback.Call_Callback(data);
                // Unsubscribe from the provision response topic.
                // Will be resubscribed if another request is sent anyway
                (void)Provision_Unsubscribe();
        }

        bool Is_Response_Topic_Matching(char const * topic) const override {
                return strncmp(PROV_RESPONSE_TOPIC, topic, strlen(PROV_RESPONSE_TOPIC) + 1) == 0;
        }

        bool Unsubscribe() override {
                return Provision_Unsubscribe();
        }

        bool Resubscribe_Permanent_Subscriptions() override {
                m_provision_callback = Provision_Callback();
                return true;
        }

#if !THINGSBOARD_USE_ESP_TIMER
        void loop() override {
                auto & request_callback = m_provision_callback.Get_Request_Timeout();
                request_callback.Update_Timeout_Timer();
        }
#endif // !THINGSBOARD_USE_ESP_TIMER

        void Initialize() override {
                // Nothing to do
        }

        void Set_Client_Callbacks(Callback<void, IAPI_Implementation &>::function subscribe_api_callback, Callback<bool, char const * const, JsonDocument const &, Deserialization_Options>::function send_json_callback, Callback<bool, char const * const, char const * const>::function send_json_string_callback, Callback<bool, char const * const>::function subscribe_topic_callback, Callback<bool, char const * const>::function unsubscribe_topic_callback, Callback<uint16_t>::function get_receive_size_callback, Callback<uint16_t>::function get_send_size_callback, Callback<bool, uint16_t, uint16_t>::function set_buffer_size_callback, Callback<size_t *>::function get_request_id_callback) override {
                m_send_json_callback.Set_Callback(send_json_callback);
        }

private:
        /// @brief Subscribes to provision response topic
        /// @param callback Callback method that will be called when the requested provisioning response has been received
        /// @return Whether subscribing to the provision response topic, was successful or not
        bool Provision_Subscribe(Provision_Callback const & callback) {
                m_provision_callback = callback;
                return true;
        }

        /// @brief Unsubscribes the provision response callback
        /// @return Whether unsubscribing from the provision response topic, was successful or not
        bool Provision_Unsubscribe() {
                return Resubscribe_Permanent_Subscriptions();
        }

        Callback<bool, char const * const, JsonDocument const &, Deserialization_Options> m_send_json_callback = {};         // Send json document callback

        Provision_Callback                                       m_provision_callback = {};         // Provision response callback
};

#endif // Provision_h