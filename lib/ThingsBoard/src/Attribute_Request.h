#ifndef Attribute_Request_h
#define Attribute_Request_h

// Local includes.
#include "Attribute_Request_Callback.h"
#include "IAPI_Implementation.h"
#include "Timeoutable_Request.h"


// Attribute request API topics.
char constexpr ATTRIBUTE_REQUEST_TOPIC_TEMPLATE[] = "v1/devices/me/attributes/request/%u";
char constexpr ATTRIBUTE_RESPONSE_SUBSCRIBE_TOPIC[] = "v1/devices/me/attributes/response/+";
char constexpr ATTRIBUTE_RESPONSE_TOPIC_BASE[] = "v1/devices/me/attributes/response/";
// Client side attribute request keys.
char constexpr CLIENT_REQUEST_KEYS[] = "clientKeys";
char constexpr CLIENT_RESPONSE_KEY[] = "client";
// Shared attribute request keys.
char constexpr SHARED_REQUEST_KEY[] = "sharedKeys";
// char constexpr SHARED_RESPONSE_KEY[] = "shared";
// Log messages.
#if THINGSBOARD_ENABLE_DEBUG
char constexpr NO_KEYS_TO_REQUEST[] = "No keys to request were given";
char constexpr ATT_KEY_NOT_FOUND[] = "Attribute key in Attribute_Request_Callback is NULL";
char constexpr ATT_KEY_IS_NULL[] = "Requested attribute key is NULL";
#endif // THINGSBOARD_ENABLE_DEBUG
#if !THINGSBOARD_ENABLE_DYNAMIC
char constexpr CLIENT_SHARED_ATTRIBUTE_SUBSCRIPTIONS[] = "client or shared attribute request";
#endif // THINGSBOARD_ENABLE_DYNAMIC


/// @brief Handles the internal implementation of the ThingsBoard client and shared Attribute Request API.
/// See https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server for more information
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = UdawaThingsboardLogger
#if THINGSBOARD_ENABLE_DYNAMIC
template <typename Logger = UdawaThingsboardLogger>
#else
/// @tparam MaxSubscriptions Maximum amount of simultaneous client or shared attribute requests.
/// Once the maximum amount has been reached it is not possible to increase the size, this is done because it allows to allocate the internal memory on the stack instead of the heap.
/// Especially relevant for the value of this template parameters is that once the attributes have been received the call is automatically cleaned up allowing to request attributes again.
/// This means the number should represent the maximum amount of responses to attribute requests the device calling the internal methods is ever waiting for, default = DEFAULT_SUBSCRIPTION_AMOUNT (1)
/// @tparam MaxAttributes Maximum amount of attributes that will ever be requested at once with the Attribute_Request_Callback, allows to use an array on the stack in the background, default = DEFAULT_ATTRIBUTES_AMOUNT (1)
template<size_t MaxSubscriptions = DEFAULT_SUBSCRIPTION_AMOUNT, size_t MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT, typename Logger = UdawaThingsboardLogger>
#endif // THINGSBOARD_ENABLE_DYNAMIC
class Attribute_Request : public IAPI_Implementation {
#if THINGSBOARD_ENABLE_DYNAMIC
    using Callback_Value = Attribute_Request_Callback;
    using Callback_Container = Container<Callback_Value>;
#else
    using Callback_Value = Attribute_Request_Callback<MaxAttributes>;
    using Callback_Container = Container<Callback_Value, MaxSubscriptions>;
#endif // THINGSBOARD_ENABLE_DYNAMIC

  public:
    /// @brief Constructor
    Attribute_Request() = default;

    ~Attribute_Request() override = default;

    /// @brief Requests one client-side attribute, which will call the passed callback.
    /// If the key-value pair from the server for the requested client-side attributes has been received
    /// @note Because the client-side attribute request is a single event subscription, meaning we only ever receive one response for one request,
    /// the request is automatically unsubscribde and the internally allocated data for the request deleted as soon as the response has been received and handled by the subscribed callback.
    /// See https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server for more information
    /// @param callback Callback method that will be called when the requested client-side attributes has been received
    /// @return Whether sending the request to the cloud was successfull. Is non-blocking and therefore a true value returned by this method does not guarantee a response will ever be received.
    /// If wanted by the user the optional timeout callback and timeout time in the callback instance can be configured,
    /// which will inform the user by calling the timeout callback, if no response has been received by the server in the expected time
    bool Client_Attributes_Request(Callback_Value const & callback) {
        return Attributes_Request(callback, CLIENT_REQUEST_KEYS, CLIENT_RESPONSE_KEY);
    }

    /// @brief Requests one shared attribute, which will call the passed callback.
    /// If the key-value pair from the server for the requested shared attributes has been received
    /// @note Because the shared attribute request is a single event subscription, meaning we only ever receive one response for one request,
    /// the request is automatically unsubscribde and the internally allocated data for the request deleted as soon as the response has been received and handled by the subscribed callback.
    /// See https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server for more information
    /// @param callback Callback method that will be called when the requested client-side attributes has been received
    /// @return Whether sending the request to the cloud was successfull. Is non-blocking and therefore a true value returned by this method does not guarantee a response will ever be received.
    /// If wanted by the user the optional timeout callback and timeout time in the callback instance can be configured,
    /// which will inform the user by calling the timeout callback, if no response has been received by the server in the expected time
    bool Shared_Attributes_Request(Callback_Value const & callback) {
        return Attributes_Request(callback, SHARED_REQUEST_KEY, SHARED_RESPONSE_KEY);
    }

    API_Process_Type Get_Process_Type() const override {
        return API_Process_Type::JSON;
    }

    void Process_Response(char const * topic, uint8_t * payload, uint32_t length) override {
        // Nothing to do
    }

    void Process_Json_Response(char const * topic, JsonDocument const & data) override {
        auto const request_id = Helper::Split_Topic_Into_Request_ID(topic, strlen(ATTRIBUTE_RESPONSE_TOPIC_BASE));
        JsonObjectConst object = data.as<JsonObjectConst>();

        Timeoutable_Request * request_callback = nullptr;
        auto it = std::find_if(m_attribute_request_callbacks.begin(), m_attribute_request_callbacks.end(), [&request_id](Callback_Value & attribute_request) {
            return attribute_request.Get_Request_ID() == request_id;
        });
        if (it != m_attribute_request_callbacks.end()) {
            auto & attribute_request = *it;
            char const * attribute_response_key = attribute_request.Get_Attribute_Key();
            if (attribute_response_key == nullptr) {
#if THINGSBOARD_ENABLE_DEBUG
                Logger::printfln(ATT_KEY_NOT_FOUND);
#endif // THINGSBOARD_ENABLE_DEBUG
                goto delete_callback;
            }

            if (object[attribute_response_key].is<JsonVariant>()) {
                object = object[attribute_response_key];
            }

            request_callback = &attribute_request.Get_Request_Timeout();
            request_callback->Stop_Timeout_Timer();
            attribute_request.Call_Callback(object);

            delete_callback:
            // Delete callback because the changes have been requested and the callback is no longer needed
            m_attribute_request_callbacks.erase(it);
        }

        // Unsubscribe from the shared attribute request topic,
        // if we are not waiting for any further responses with shared attributes from the server.
        // Will be resubscribed if another request is sent anyway
        if (m_attribute_request_callbacks.empty()) {
            (void)Attributes_Request_Unsubscribe();
        }
    }

    bool Is_Response_Topic_Matching(char const * topic) const override {
        return strncmp(ATTRIBUTE_RESPONSE_TOPIC_BASE, topic, strlen(ATTRIBUTE_RESPONSE_TOPIC_BASE)) == 0;
    }

    bool Unsubscribe() override {
        return Attributes_Request_Unsubscribe();
    }

    bool Resubscribe_Permanent_Subscriptions() override {
        m_attribute_request_callbacks.clear();
        return true;
    }

#if !THINGSBOARD_USE_ESP_TIMER
    void loop() override {
        for (auto & attribute_request : m_attribute_request_callbacks) {
            auto & request_callback = attribute_request.Get_Request_Timeout();
            request_callback.Update_Timeout_Timer();
        }
    }
#endif // !THINGSBOARD_USE_ESP_TIMER

    void Initialize() override {
        // Nothing to do
    }

    void Set_Client_Callbacks(Callback<void, IAPI_Implementation &>::function subscribe_api_callback, Callback<bool, char const * const, JsonDocument const &, Deserialization_Options>::function send_json_callback, Callback<bool, char const * const, char const * const>::function send_json_string_callback, Callback<bool, char const * const>::function subscribe_topic_callback, Callback<bool, char const * const>::function unsubscribe_topic_callback, Callback<uint16_t>::function get_receive_size_callback, Callback<uint16_t>::function get_send_size_callback, Callback<bool, uint16_t, uint16_t>::function set_buffer_size_callback, Callback<size_t *>::function get_request_id_callback) override {
        m_send_json_callback.Set_Callback(send_json_callback);
        m_subscribe_topic_callback.Set_Callback(subscribe_topic_callback);
        m_unsubscribe_topic_callback.Set_Callback(unsubscribe_topic_callback);
        m_get_request_id_callback.Set_Callback(get_request_id_callback);
    }

  private:
    bool Attributes_Request(Callback_Value const & callback, char const * attribute_request_key, char const * attribute_response_key) {
        auto const & attributes = callback.Get_Attributes();

        // Check if any sharedKeys were requested
        if (attributes.empty()) {
#if THINGSBOARD_ENABLE_DEBUG
            Logger::printfln(NO_KEYS_TO_REQUEST);
#endif // THINGSBOARD_ENABLE_DEBUG
            return false;
        }
        else if (attribute_request_key == nullptr || attribute_response_key == nullptr) {
#if THINGSBOARD_ENABLE_DEBUG
            Logger::printfln(ATT_KEY_NOT_FOUND);
#endif // THINGSBOARD_ENABLE_DEBUG
            return false;
        }

        Callback_Value * registered_callback = nullptr;
        if (!Attributes_Request_Subscribe(callback, registered_callback)) {
            return false;
        }
        else if (registered_callback == nullptr) {
            return false;
        }

        // String are const char* and therefore stored as a pointer --> zero copy, meaning the size for the strings is 0 bytes,
        // Data structure size depends on the amount of key value pairs passed + the default clientKeys or sharedKeys
        // See https://arduinojson.org/v7/assistant/ for more information on the needed size for the JsonDocument
        JsonDocument request_buffer;

        // Calculate the size required for the char buffer containing all the attributes seperated by a comma,
        // before initalizing it so it is possible to allocate it on the stack
        size_t size = 0U;
        for (auto const & att : attributes) {
            if (Helper::String_IsNull_Or_Empty(att)) {
                continue;
            }

            size += strlen(att);
            size += strlen(",");
        }

        // Add space for null termination at the end of the char array, has to be done,
        // because we later cast it to const char *, meaning the original size information is lost
        // and is instead handled by null termination at the end of the string
        size += 1;

        // Initalizes complete array to 0, required because strncat needs both destination and source to contain proper null terminated strings
        char request[size] = {};
        for (auto const & att : attributes) {
            if (Helper::String_IsNull_Or_Empty(att)) {
#if THINGSBOARD_ENABLE_DEBUG
                Logger::printfln(ATT_KEY_IS_NULL);
#endif // THINGSBOARD_ENABLE_DEBUG
                continue;
            }

            strncat(request, att, size);
            size -= strlen(att);
            strncat(request, ",", size);
            size -= strlen(",");
        }

        // Ensure to cast to const, this is done so that ArduinoJson does not copy the value but instead simply store the pointer, which does not require any more memory,
        // besides the base size needed to allocate one key-value pair. Because if we don't the char array would be copied
        // and because there is not enough space the value would simply be "undefined" instead. Which would cause the request to not be sent correctly
        request_buffer[attribute_request_key] = static_cast<const char*>(request);

        size_t * p_request_id = m_get_request_id_callback.Call_Callback();
        if (p_request_id == nullptr) {
            Logger::printfln(REQUEST_ID_NULL);
            return false;
        }
        auto & request_id = *p_request_id;

        registered_callback->Set_Request_ID(++request_id);
        registered_callback->Set_Attribute_Key(attribute_response_key);
        auto & request_callback = registered_callback->Get_Request_Timeout();
        request_callback.Start_Timeout_Timer();

        char topic[Helper::Calculate_Print_Size(ATTRIBUTE_REQUEST_TOPIC_TEMPLATE, request_id)] = {};
        (void)snprintf(topic, sizeof(topic), ATTRIBUTE_REQUEST_TOPIC_TEMPLATE, request_id);
        return m_send_json_callback.Call_Callback(topic, request_buffer, Deserialization_Options::NONE);
    }

    /// @brief Subscribes to attribute response topic
    /// @param callback Callback method that will be called when the requested client-side attributes has been received
    /// @param registered_callback Editable pointer to a reference of the local version that was copied from the passed callback
    /// @return Whether subscribing to the attribute response topic, was successful or not
    bool Attributes_Request_Subscribe(Callback_Value const & callback, Callback_Value * & registered_callback) {
#if !THINGSBOARD_ENABLE_DYNAMIC
        if (m_attribute_request_callbacks.size() + 1 > m_attribute_request_callbacks.capacity()) {
            Logger::printfln(MAX_SUBSCRIPTIONS_EXCEEDED, CLIENT_SHARED_ATTRIBUTE_SUBSCRIPTIONS, MAX_SUBSCRIPTIONS_TEMPLATE_NAME);
            return false;
        }
#endif // !THINGSBOARD_ENABLE_DYNAMIC
        if (!m_subscribe_topic_callback.Call_Callback(ATTRIBUTE_RESPONSE_SUBSCRIBE_TOPIC)) {
            Logger::printfln(SUBSCRIBE_TOPIC_FAILED, ATTRIBUTE_RESPONSE_SUBSCRIBE_TOPIC);
          return false;
        }
        m_attribute_request_callbacks.push_back(callback);
        registered_callback = &m_attribute_request_callbacks.back();
        return true;
    }

    /// @brief Unsubscribes all client-side or shared attributes request callbacks
    /// @return Whether unsubscribing from the attribute response topic, was successful or not
    bool Attributes_Request_Unsubscribe() {
        (void)Resubscribe_Permanent_Subscriptions();
        return m_unsubscribe_topic_callback.Call_Callback(ATTRIBUTE_RESPONSE_SUBSCRIBE_TOPIC);
    }

    Callback<bool, char const * const, JsonDocument const &, Deserialization_Options> m_send_json_callback = {};          // Send json document callback
    Callback<bool, char const * const>                       m_subscribe_topic_callback = {};    // Subscribe mqtt topic client callback
    Callback<bool, char const * const>                       m_unsubscribe_topic_callback = {};  // Unubscribe mqtt topic client callback
    Callback<size_t *>                                       m_get_request_id_callback = {};     // Get internal request id callback
    Callback_Container                                       m_attribute_request_callbacks = {}; // Client-side or shared attribute request callback vector
};

#endif // Attribute_Request_h