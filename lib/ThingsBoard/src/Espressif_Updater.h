#ifndef Espressif_Updater_h
#define Espressif_Updater_h

// Local include.
#include "Configuration.h"

#if THINGSBOARD_USE_ESP_PARTITION

// Local include.
#include "IUpdater.h"

// Library include.
#include <esp_ota_ops.h>

constexpr char INVALID_OTA_PARTIION[] = "The running partition and the parition we wanted to boot into were not the same meaning the previous update failed and choose the fallback partition instead";
constexpr char MISSING_OTA_APP[] = "Missing second ota app or app was invalid";
constexpr char BEGIN_UPDATE_FAILED[] = "Beginning update failed with error reason (%s)";


/// @brief IUpdater implementation that uses the Over the Air Update API from Espressif (https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ota.html)
/// under the hood to write the given binary firmware data into flash memory so the device can restart with the newly received firmware
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = DefaultLogger
template <typename Logger = DefaultLogger>
class Espressif_Updater : public IUpdater {
  public:
    Espressif_Updater() = default;

    /// @brief Deleted copy constructor
    /// @note Copying an active Updater is not possible and there are no settings or configuration to copy. Therefore copying is disabled alltogether
    /// @param other Other instance we disallow copying from
    Espressif_Updater(Espressif_Updater const & other) = delete;

    /// @brief Deleted copy assignment operator
    /// @note Copying an active Updater is not possible and there are no settings or configuration to copy. Therefore copying is disabled alltogether
    /// @param other Other instance we disallow copying from
    void operator=(Espressif_Updater const & other) = delete;

    ~Espressif_Updater() override {
        reset();
    }

    bool begin(size_t const & firmware_size) override {
        esp_partition_t const * running = esp_ota_get_running_partition();
        esp_partition_t const * configured = esp_ota_get_boot_partition();

        if (configured != running) {
            Logger::printfln(INVALID_OTA_PARTIION);
            return false;
        }

        esp_partition_t const * update_partition = esp_ota_get_next_update_partition(nullptr);

        if (update_partition == nullptr) {
            Logger::printfln(MISSING_OTA_APP);
            return false;
        }

        esp_err_t const error = esp_ota_begin(update_partition, firmware_size, &m_ota_handle);

        if (error != ESP_OK) {
            Logger::printfln(BEGIN_UPDATE_FAILED, esp_err_to_name(error));
            return false;
        }

        m_update_partition = update_partition;
        return true;
    }

    size_t write(uint8_t * payload, size_t const & total_bytes) override {
        esp_err_t const error = esp_ota_write(m_ota_handle, payload, total_bytes);
        auto const written_bytes = (error == ESP_OK) ? total_bytes : 0U;
        return written_bytes;
    }

    void reset() override {
#if defined(ESP8266) || (ESP_IDF_VERSION_MAJOR == 4 && ESP_IDF_VERSION_MINOR < 3) || ESP_IDF_VERSION_MAJOR < 4
        (void)end();
#else
        (void)esp_ota_abort(m_ota_handle);
#endif
    }

    bool end() override {
        esp_err_t error = esp_ota_end(m_ota_handle);
        if (error != ESP_OK) {
            return false;
        }

        error = esp_ota_set_boot_partition(m_update_partition);
        return error == ESP_OK;
    }

  private:
    esp_ota_handle_t      m_ota_handle = {};        // ESP OTA hanle that is used to to access the underlying updater
    esp_partition_t const *m_update_partition = {}; // Non active OTA partition that we write our data into
};

#endif // THINGSBOARD_USE_ESP_PARTITION

#endif // Espressif_Updater_h
